#!/usr/bin/env python3
import os
import sys
import signal
import threading
import argparse
import subprocess
from pathlib import Path
from rich.console import Console
from contextlib import redirect_stderr, redirect_stdout
from flask import Flask
import logging

import webview

# traceback.install(show_locals=True)

from hyprsettings_utils.argument_parser import createArgParse
from hyprsettings_utils.shared import hs_globals, state
from hyprsettings_utils.flask_routes import register_routes
from hyprsettings_utils.utils import is_port_open
from hyprsettings_utils.window_manager import *
from hyprsettings_utils.hyprland_wiki import register_markdown_routes

os.environ['GDK_BACKEND'] = 'wayland'
os.environ['FLASK_SKIP_DOTENV'] = '1'
console = Console()
werlog = logging.getLogger('werkzeug')
werlog.setLevel(logging.ERROR)

thisfile_path = Path(__file__).parent.resolve()


def start_flask_server():
	state.app = Flask(__name__)
	register_routes(state.app)
	register_markdown_routes(state.app)
	while is_port_open(port=state.flask_port):
		state.flask_port += 1
	log(f'You can access the ui on [blue][link=localhost:{state.flask_port}]localhost:{state.flask_port}[/link][/blue]')
	state.app.run(host=hs_globals.HOST, port=state.flask_port, use_reloader=False)


def ui_print(*args, **kwargs):
	console.print('[blue][UIBackend][/blue]', *args, **kwargs)


def warn(msg):
	log(f'[red]{msg}[red]')


_last_log_message = None
_last_log_count = 1


def log(msg, prefix='', only_verbose=False):
	global _last_log_message, _last_log_count

	prefix_str = f'{prefix}' if prefix else ''
	full_message = f'{prefix_str} {msg}'

	if not only_verbose or state.verbose:
		if full_message == _last_log_message:
			_last_log_count += 1

			console.file.write('\033[F\033[K')
			ui_print(f'{full_message} [dim](×{_last_log_count})[/dim]')
		else:
			ui_print(f'{full_message}')
			_last_log_message = full_message
			_last_log_count = 1


def handle_interrupt(signum, frame):
	log('Sigint signal detected! Cleaning up...')
	log('Exited cleanly.')
	os._exit(0)


def kill_hyprsettings():
	log('Killing all hyprsettings instances')
	result = subprocess.run(['pkill', '-f', 'hyprsettings'])
	if (state.vite_process is not None) and (state.vite_process.poll() is None):
		log('Killing bun vite process')
		os.killpg(state.vite_process.pid, signal.SIGTERM)
		try:
			state.vite_process.wait(timeout=5)
		except subprocess.TimeoutExpired:
			log('Bun vite process did not terminate in time. Forcing kill.')
			os.killpg(state.vite_process.pid, signal.SIGKILL)
	print(result)
	if result.returncode == 0:
		log('Hyprsettings killed')
	else:
		log('No actively running hyprsettings found.')
	sys.exit(0)


def print_title():
	art = f"""\
	
 [bold][blue]  ╻ ╻╻ ╻┏━┓┏━┓┏━┓┏━╸╺┳╸╺┳╸╻┏┓╻┏━╸┏━┓
   ┣━┫┗┳┛┣━┛┣┳┛┗━┓┣╸  ┃  ┃ ┃┃┗┫┃╺┓┗━┓
   ╹ ╹ ╹ ╹  ╹┗╸┗━┛┗━╸ ╹  ╹ ╹╹ ╹┗━┛┗━┛[/bold][/blue]
      version [green][bold]{hs_globals.CURRENT_VERSION}[/bold][/green]\n [blue][link=https://github.com/acropolis914/hyprsettings] github.com/acropolis914/hyprsettings[/link][/blue]\n"""
	console.print(art, style='')
	# return art


class LogFilter:
	@staticmethod
	def raw_bytes_for(text, original_raw_bytes):
		# Helper to produce raw bytes when we altered the text.
		if original_raw_bytes is not None:
			# encode using default encoding with replace (safe)
			return text.encode(sys.getdefaultencoding(), errors='replace')
		return None

	def write(self, data):
		if not data:
			return

		raw_bytes = None
		# Normalize input to text for filtering
		if isinstance(data, (bytes, bytearray)):
			raw_bytes = bytes(data)
			text = raw_bytes.decode(sys.getdefaultencoding(), errors='replace')
		else:
			text = str(data)

		if not text.strip():
			return

		# Filter common noise
		if '[pywebview]' in text:
			# keep pywebview handling below if needed
			pass
		elif 'GET /' in text and 'HTTP' in text and not state.verbose:
			return
		elif 'Bottle v' in text and not state.verbose:
			return
		elif 'python-dotenv' in text:
			return

		# Replace leading " * " (Flask banner) with empty string and forward
		if text.startswith(' * '):
			cleaned = text[3:].replace('\n', '')
			log(cleaned, '[green][ Flask][/green]')
			# self._write_out(f"[Flask]{cleaned}", self.raw_bytes_for(cleaned, raw_bytes))
			return

		if text.startswith('[pywebview]'):
			new_text = text.replace('[pywebview]', '')
			log(new_text, '[green]pywebview[/green]')
			return

		# Default: write original text
		self._write_out(text, raw_bytes)

	def flush(self):
		try:
			sys.__stdout__.flush()
		except Exception:
			pass
		try:
			if hasattr(sys.__stdout__, 'buffer'):
				sys.__stdout__.buffer.flush()
		except Exception:
			pass

	def _write_out(self, text, raw_bytes):
		# Try text write first; if underlying expects bytes, fall back to buffer
		try:
			# return
			sys.__stdout__.write(text)
		except TypeError:
			# return
			# underlying stdout wants bytes
			try:
				buf = sys.__stdout__.buffer
				if raw_bytes is not None:
					buf.write(raw_bytes)
				else:
					buf.write(text.encode(sys.getdefaultencoding(), errors='replace'))
			except Exception:
				# last resort
				try:
					sys.__stdout__.write(text.encode('utf-8', errors='replace'))
				except Exception:
					pass


# WINDOW FUNCTIONS
def on_loaded(window):
	# log("DOM is ready")
	window.events.loaded -= on_loaded


def on_closing(window):
	disabled_dmabuf = os.environ.get('WEBKIT_DISABLE_DMABUF_RENDERER')
	if state.daemon and (disabled_dmabuf is None or disabled_dmabuf != '1'):
		state.window_instance.hide()
		state.window_visible = False
		log('[yellow]Called close window. Window is hidden since daemon is enabled[/yellow]')
		return False
	else:
		if disabled_dmabuf == '1':
			log('Environment variable "WEBKIT_DISABLE_DMABUF_RENDERER" is set to 1.')
			log('Restoring from daemon will fail. Daemon setting is dishonored.')
		log('Window closed. Terminating process.')
		os._exit(0)
		# kill_hyprsettings()
		return None
	# print("______________________________________________\n")
	# os._exit(0)


# ------------------- Socket toggle functions -------------------
def handle_client(conn):
	try:
		data = conn.recv(1024)
		if data.decode() == 'TOGGLE' and state.window_instance:
			activeworkspace = (
				subprocess.run(
					"hyprctl monitors -j | jq '.[] | select(.focused==true) | .activeWorkspace.name'",
					shell=True,
					capture_output=True,
					text=True,
				)
				.stdout.strip()
				.strip('"')
			)
			log(f"Active workspace from focused monitor: '{activeworkspace}'")

			specialworkspace = (
				subprocess.run(
					"hyprctl monitors -j | jq '.[] | select(.focused==true) | .specialWorkspace.name'",
					shell=True,
					capture_output=True,
					text=True,
				)
				.stdout.strip()
				.strip('"')
			)
			log(
				f"Special workspace from focused monitor: '{specialworkspace}'",
				only_verbose=True,
			)

			if specialworkspace:
				log(f'Special workspace {specialworkspace} detected, overriding active workspace')
				activeworkspace = specialworkspace
			log(f"Workspace to target: '{activeworkspace}'", only_verbose=True)

			# get hyprsettings window workspace
			hyprsettings_window_workspace_name = subprocess.run(
				'hyprctl -j clients | jq -r \'.[] | select(.initialClass=="hyprsettings") | .workspace.name\'',
				shell=True,
				capture_output=True,
				text=True,
			).stdout.strip()
			log(
				f"HyprSettings window currently on workspace: '{hyprsettings_window_workspace_name}'",
				only_verbose=True,
			)

			# main toggle logic
			if state.window_visible and activeworkspace == hyprsettings_window_workspace_name:
				log(f'Window visible AND on current workspace ({activeworkspace}) → hiding')
				state.window_instance.hide()
				state.window_visible = False

			elif state.window_visible and activeworkspace != hyprsettings_window_workspace_name:
				log(f'Window visible BUT on different workspace ({hyprsettings_window_workspace_name}) → moving')
				move = subprocess.run(
					[
						'hyprctl',
						'dispatch',
						'movetoworkspace',
						f'{activeworkspace},initialclass:hyprsettings',
					],
					capture_output=True,
					text=True,
				)
				state.window_instance.restore()  # restore if minimized
				state.window_instance.show()
				state.window_visible = True

			else:
				log('Window not visible → restoring and showing')
				state.window_instance.restore()  # restore if minimized
				state.window_instance.show()
				state.window_visible = True

	except Exception as e:
		log(e)

	finally:
		conn.close()


def start_window_server():
	with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as window_socket:
		window_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
		window_socket.bind((hs_globals.HOST, state.webview_port))
		window_socket.listen()
		while True:
			conn, addr = window_socket.accept()
			threading.Thread(target=handle_client, args=(conn,), daemon=True).start()


def main():
	state.flask_thread = threading.Thread(target=start_flask_server, daemon=True)
	state.flask_thread.start()

	# state.hyprland_wiki_thread = threading.Thread(target=start_hyprland_wiki_server, daemon=True)
	# state.hyprland_wiki_thread.start()

	try:
		# mimetypes.add_type('application/javascript', '.js')
		if state.args.no_devtools:
			webview.settings['OPEN_DEVTOOLS_IN_DEBUG'] = False
		if state.args.no_dmabuf:
			os.environ['WEBKIT_DISABLE_DMABUF_RENDERER'] = '1'
		ui_link = f'http://localhost:{state.flask_port}/'
		if state.args.bun_dev:
			ui_link = 'http://localhost:3000/'
			log('Using bun dev server at localhost:3000 as per --bun-dev arg')

		if not state.args.no_window:
			state.window_thread = threading.Thread(target=start_window_server, daemon=state.daemon)
			state.window_thread.start()
			log('Starting webview window...')
			state.window_instance = webview.create_window(
				'HyprSettings',
				ui_link,
				# js_api=api,
				transparent=True,
				width=800,
				height=600,
				easy_drag=True,
				min_size=(400, 300),
				hidden=state.args.hidden,
			)
			state.window_visible = not state.args.hidden
			state.window_instance.events.loaded += on_loaded
			state.window_instance.events.closing += on_closing
			webview.start(
				gui=state.args.ui[0],
				debug=state.args.debug,
				private_mode=True,
				storage_path=str(hs_globals.CACHE_PATH),
				icon='icon-48.png',
			)
			sys.exit(0)
		else:
			log('Opening in browser mode only as per --no-window arg')
			log('[red][bold] Warning [/bold][/red] Using firefox-based browsers feel [red]slower[/red]')
			log('If you experience loading times > 2 seconds, consider using a chromium-based browser.')
			log("Even I, acropolis, who uses Zen Browser, can't deny that (ノToT)ノ ~┻┻")
			log(f'Opening {ui_link} in default browser')
			if not state.args.no_browser:
				subprocess.run(['xdg-open', ui_link])
			while True:
				pass

	except Exception as e:
		log(e)
		log('I am ded')
		os._exit(1)


if __name__ == '__main__':
	parser = argparse.ArgumentParser(
		prog='hyprsettings',
		description='A loyal hyprland parser and gui editor for hyprland.conf',
		epilog=print_title(),
	)
	parser.add_argument('-v', '--version', action='version', version='%(prog)s {print_title()}')
	parser = createArgParse(parser)

	state.args = parser.parse_args()

	signal.signal(signal.SIGINT, handle_interrupt)

	if state.args.kill:
		kill_hyprsettings()

	if state.args.ui:
		log(f'Using UI {state.args.ui}')
	log(f'Debug mode: {state.args.debug}')
	log(f'Verbose: {state.args.verbose}')
	log(f'Daemon: {not state.args.no_daemon and state.args.daemon}')
	log(f'Window: {not state.args.no_window}')

	if state.args.hidden:
		state.window_visible = False
	if state.args.config:
		log(f'Given custom config path: {state.args.config}')
		if str(state.args.config).endswith('.conf'):
			state.hyprland_config_path = Path(str(state.args.config).strip('"').strip("'"))
		else:
			warn(f'Given config file is not a ".conf file". Using default config path {state.hyprland_config_path}')
	state.daemon = not state.args.no_daemon and state.args.daemon
	if state.args.debug:
		log(
			'[red]DEBUG MODE IS TURNED ON[/red]. It sometimes stutter on my (acropolis) machine. Maybe some pywebview memory leak. I ain`t fixing that!'
		)
	if state.args.verbose:
		state.verbose = state.args.verbose

	def gotoMain():
		with redirect_stderr(LogFilter()), redirect_stdout(LogFilter()):
			main()

	if state.args.no_daemon and state.args.daemon:
		log('Damn. Running "--no-daemon" and "--daemon" at the same time? Why?')

	if state.args.no_daemon:
		while is_port_open(state.webview_port):
			log(f'Port {state.webview_port} in use by existing daemon.')
			log("Run with '-d' to use that exisitng daemon.")
			log('Daemon uses RAM but starts faster.')
			state.webview_port += 1
		log(f'Using port {state.webview_port} for the no daemon pywebview window.', only_verbose=True)

	if not state.args.no_daemon and is_port_open(state.webview_port):
		if send_toggle():
			exit(0)

	gotoMain()
